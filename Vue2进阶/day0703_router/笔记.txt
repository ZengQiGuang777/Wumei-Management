面试题：说说你对 SPA 单页面的理解，它的优缺点分别是什么？
看图...

==========================
面试题：介绍一下路由的两种实现模式：hash模式 和 history模式
在SPA单页面应用中，主要是基于前端路由机制去管理的，无论使用何种路由模式，有一个重要的前提：路由切换，浏览器地址栏中的地址可以发生改变，但是不能让页面刷新！
  @1 哈希(Hash)路由
    + 原理：每一次路由切换，都是改变了页面的哈希值(但页面不会刷新)；vue-router内部会监测哈希值的改变「事件：hashchange」，获取最新的哈希值；然后拿最新的哈希值去“路由表”中进行匹配，把匹配的组件，放在指定容器中渲染（之前渲染的组件则被销毁「彻底销毁，包含真实DOM」）！
    + 哈希路由模式是一种非常简单、且方便操作的路由模式，只不过有人认为它比较“丑”「或者说不太那么真实，因为印象中，页面的切换是地址的变化，而不是单纯哈希值的变化」
  @2 History（浏览器）路由
    + 原理：借助H5中提供的HistoryAPI，实现路由的切换，这样“页面地址”会跟着改变，但是不会让页面刷新；在每一次切换后，获取最新的页面地址，去路由表中进行匹配，把匹配的内容放在指定容器中渲染！而且会监测popstate事件，在触发回退/前进操作的时候，这个事件会触发，也进行路由的匹配！
      HistoryAPI
      + pushState(状态对象,'标题','地址')
      + replaceState  替换历史记录池中当前的记录，换成新跳转的地址
      + back 回退一步 =>> go(-1)
      + forward 前进一步 =>> go(1)
      + go 回退或者前进到哪一步
    + History路由，其路由跳转的地址，看上去真实很多（弥补了哈希路由的缺陷），但它存储在一个更严重的问题：
      + 真实页面只有一个，但是路由切换的地址有很多，这些地址是我们虚构的，并不真实存在
      + 基于pushState跳转的时候，页面不刷新，渲染的是真实页面，在真实页面中根据虚构的地址，匹配每个组件/内容，然后进行渲染即可
      + 但是如果页面在每个虚构的地址上刷新了，此时向服务器发送请求，服务器返回的是404「找不到资源」
    + 所以 History路由 是需要 “服务器配合” 完成的：在客户端访问的页面地址不存在的情况下，不要返回404错误页面，而是返回唯一真实的页面即可！
在我之前项目开发中，我一般都是基于 哈希路由模式 来管理前端路由机制的，主要原因是：不需要服务器配合，操作简便！

==========================
面试题：说一下路由跳转的方案及传参方式有哪些？
实现路由跳转有两种方案：
  + 基于 <router-link> 实现跳转
    + 渲染后的结果是A标签：但是<router-link>可以自动识别路由的模式，控制A标签的href值；而且还会和当前的路由地址进行匹配，把相匹配的导航设置 router-link-active/router-link-exact-active 选中的样式类！最后<router-link>的语法更强大，不仅指定了跳转的地址，还有相应的传参信息！
    + <router-link to="/personal"> 以push方式（新增历史记录），跳转到 /personal 路由
    + <router-link to="/personal" replace> 设置replace，则不会新增历史记录，而是替换现有的历史记录
    + to属性的值可以是一个对象
      :to="{
        path:'/personal',
        query:{
            ... //实现问号传参
        }
      }"
      :to="{
        name:'personal', //以命名路由的方式跳转
        params:{
            ... //命名路由的传参方案「隐式传参」
        }
      }"
    + 设置 exact 属性后，当前 <router-link> 只能进行精准匹配，一般只用于地址是 / 情况！
  + 基于 “编程式导航”「也就是this.$router中提供的方法」实现跳转
    相关的方法
    + back
    + forward
    + go
    + push ：和 <router-link> 中 to 属性的语法一致
    + replace
而且这两种方案中，即支持按照路径跳转，也支持按照路由名字跳转！

在路由跳转过程中，我们可以传递一些信息，总结下来有三种传参方案：
  + 问号传参「适用于 路径/名字 跳转」
    优势：传参的信息在地址栏中存在，即便在目标页面刷新，传递的信息依然可以解析出来；支持路径和名字跳转；
    弊端：传递的信息暴露在地址栏中，所以不安全；并且有长度限制；而且值最后都被转为字符串；有人认为比较“丑”！
  + 路径参数「只适用于 路径 跳转」
    把传递的信息，作为路由地址规则中的一部分「所以想基于这个方案传递参数，需要先改变路由匹配的规则」
      path: 'profile/:lx?/:name?'
        + : 代表此处是传参的规则
        + ？ 代表可传可不传
    很多优缺点和问号传参是一致的，例如：安全性、长度限制、刷新不消失等等
    只不过这种方案：
      + 只能支持 路径 跳转
      + 这种方式看上去比问号传参美观一些
  + 隐式传参「只适用于 名字 跳转」
    优势：可以传递任何类型的值；传递的信息不会暴露在外面，所以安全且没有长度限制；
    弊端：只适用于名字跳转；因为传递的信息没有在地址栏中，所以在目标页面刷新，刚才传递的信息就丢失了！
这三种方案，我之前开发的时候，问号传参方式使用的最多，路径参数也经常使用，是目前比较新潮的一种方案，隐式传参很少用！

==========================
面试题：介绍一下 vue-router 中的导航守卫函数
在每一次路由切换的时候，首先把路由匹配、导航确认等事宜先处理好「在此期间会触发一系列的钩子函数，这些函数就是“路由导航守卫函数”」，然后在让组件销毁或者渲染「也就是再触发组件的相应钩子函数」！
导航守卫函数分为三类：全局守卫、路由守卫、组件内守卫，每一次路由切换的时候，其执行的大概顺序：
  @1 触发失活组件的 beforeRouteLeave
  @2 触发全局前置守卫 beforeEach
  @3 在匹配的路由表选项中，触发路由独享守卫 beforeEnter
  @4 触发激活组件的 beforeRouteEnter
  @5 触发全局解析守卫 beforeResolve
  @6 触发全局后置守卫 afterEach
  此后再触发组件的相应钩子函数：先触发激活组件的beforeCreate/created/beforeMount，然后触发失活组件的beforeDestroy/destroyed，最后触发激活组件的mounted！
在每一个导航守卫函数中，都有三个参数：to目标路由的信息、from来源路由的信息、next执行下一步的方法（afterEach中没有next）；而且next函数必须执行，否则将无法进入下一步；也可以基于next跳转到指定的路由地址（例如：在之前做登录态校验的时候，如果没有登录，基于next直接让其进入登录页）！
而在我之前的项目开发中，常用的导航守卫函数就两个：
  + beforeEach 全局前置守卫
    在这里，我处理过登录校验、权限校验、以及开启Loading等待等相关操作
  + afterEach 全局后置守卫
    在这里，我设置过页面的title、关闭Loading效果等
而且之前项目中，在路由切换的时候，会基于内置的 <keep-alive> 组件，对部分组件进行缓存；被KeepAlive缓存的组件，其beforeDestroy/destroyed钩子函数，在路由切换的时候将不再触发「组件没有销毁，只是把相关信息缓存起来了」，即便再切回到这个组件，也不会执行第一次渲染的相关逻辑了「只是把之前缓存的信息，拿出来渲染呈现即可」！但是否缓存组件，和导航守卫函数没有关系！
  被缓存的组件，在路由切换，其被失活和被激活的时候，会触发组件内的两个钩子函数
  + activated 被激活
  + deactivated 被失活
真实项目中，我们往往就是基于这一系列的钩子函数，去实现我们要做的需求！
  
==========================
面试题：介绍一下你对vue-router的理解？
+ 之前我们公司做的所有项目，基本上都是SPA单页面应用的，所以vue-router每个项目中都有应用，它主要就是基于前端路由机制，用管理单页面应用的！
+ 在使用vue-router的时候，首先要指定路由的模式，例如：哈希路由和History路由，我们之前用的都是哈希路由！
+ 然后真正写代码的时候，主要就是：Vue.use(VueRouter)、new VueRouter、以及把创建出来的router挂载到根组件的配置项中；我之前大概看过这部分源码，只有这几步操作完毕，每一个组件才会具备 $router/$route 属性，才可以使用<RouterView>/<RouterLink>两个全局组件！
+ 当然这些东西都是基础语法，没有啥难度，比较消耗经历的，还是如何根据业务需求，进行路由的划分，比如：哪些是一级，哪些是二级/三级等！我之前划分的时候，基本上都是本着：“层级不宜过深”、“按照有通用部分” 等划分原则去处理的！值得注意的是：在编写路由表的时候，一定要做路由懒加载！
+ 剩下的基本上就是在组件中，基于 <router-link> 或者 编程式导航 实现路由的跳转，以及跳转中基于各种手段进行传参，比如：问号传参、隐式传参、路径参数等！
+ 而在真正的开发中，还会使用 路由的导航守卫函数（比如：beforeEach/afterEach）做一些处理；基于 addRoute 实现动态路由管理；基于 <KeepAlive> 对某些组件做缓存，防止路由切换时组件销毁等等！
总而言之，vue-router很常用也很重要，但是也不难；在 vue-router@4 版本后，其语法和3版本略有不同，主要就是：
  + 取消VueRouter类，基于 createRouter 来创建路由管理机制
  + 基于 createWebHashHistory / createWebHistory 函数来指定路由的模式
  + 组件中基于 useRouter/useRoot 等Hook函数来获取 router和route 对象
  + ...
  主要就是配合Vue3，全面使用函数式编程，其它的和之前版本使用起来差不多！