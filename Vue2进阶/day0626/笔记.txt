如何学习Vue？
  第一条线：视图线
    + <template>或JSX语法
      + 指令「内置的14个指令和自定义指令」
      + JSX语法
    + VirtualDOM编译的机制
    + 掌握DOM-DIFF算法
    + ...
  第二条线：数据线
    + 学习 OptionsAPI/CompositionAPI 中的：语法、原理、区别等内容
    + 学习 MVVM 的原理
      + 数据是如何被监听的「Vue2和Vue3是不一样的」
      + 监听数据变化后，如何通知视图更新「观察者模式」
      + 如何监听视图的变化，以及如何让状态跟着更改「v-model」 
  第三条线：组件化开发
    + 单文件组件「含样式私有化方案的原理」
    + 类组件和函数组件
    + 复合组件通信
    + 组件封装的技巧「各种封装技巧」
      + 通用业务组件
      + UI组件库的二次封装
      + 通用功能组件
      + Vue.mixin
      + Vue.directive
      + Vue.extend
      + ...
  第四条线：实战线
    + vuex / vue-router
      + ...
    + <keep-alive>
    + <transition>
    + <component>
    + 上拉刷新、下拉加载
    + 超长列表性能优化
    + 登录/权限管理模型
    + 前后端数据通信管理方案
    + ...

==========================
Vue中的<template>语法
  + 小胡子语法 {{ }}：渲染数据
  + 小胡子语法中渲染的是“JS表达式”
    + 数据值「最后都会被转换为字符串进行渲染」
      原始值类型
        + 无法直接渲染 Symbol/BigInt 这两个函数，如果需要渲染 唯一值/大数，需要在JS中把相关的值赋值给状态/实例，再去小胡子中渲染「扩展：只有限定的一些“内置函数”，才可以直接在小胡子中使用（比如 Number/String/Boolean/parseInt/JSON.stringify...）」
        + null/undefined 会渲染为空
        + 其余的原始值类型，都会基于 String() 转换为字符串渲染
      对象类型
        + 如果是 普通对象和数组对象 ，其内部会基于 JSON.stringify 把其变为JSON字符串进行渲染
        + 而其余的对象类型值，都是基于 String() 把其变为字符串进行渲染
    + 变量/状态
    + 数学运算(或者其他的计算)
    + 判断：三元(目)运算符  条件?xxx:xxx
    + 循环：利用数组的迭代方法进行处理（例如 map/filter）
    + ...
  ---
  + 在Vue2中，每一个组件的视图，只能出现一个“根节点”
  + 而Vue3中，是允许出现多个“根节点的”
  ---
  + 提供的内置“指令”「14个」和“自定义指令”「面试题：项目开发中，常用的Vue指令有哪些」
  + 以及各个指令中的一些细节和原理
  + 如何设置样式「面试题：Class 与 Style 如何动态绑定？」
  + 样式私有化方案「面试题：在 Vue 组件 <style lang='less' scoped> 中编写的样式没有生效，都可能存在哪些原因？以及该如何解决？」

==========================
面试题：项目开发中，常用的Vue指令有哪些
我记得之前看Vue的官方文档，貌似它提供的内置指令大约有14个左右吧，具体多少个有点记不清了，但是我在之前项目开发中，常用到的指令基本就是下面这些：
  @1 v-model，主要实现MVVM双向数据驱动中的，视图更新（或者表单内容改变），可以让对应的状态也跟着更改
    + 我觉得，Vue中的v-model非常好用，尤其是处理表单元素的时候，如果没有这个指令，还需要自己手动做事件监听，手动修改状态值，这样就比较麻烦了！
    + 而且我之前封装通用组件的时候，也会给组件设置v-model，以此来快速实现，子组件中的某些操作，可以实时修改父组件中的某些信息！
  @2 v-on（也就是@），主要是给元素做事件绑定的
    + 这个指令的语法用起来很简单，尤其是不需要关注this/传参等问题，否则还需要自己基于bind来处理
    + 而且它还提供了很多事件修饰符，比如：stop/prevent/once/enter等等，还可以自定义按键修饰符，让开发起来效果高很多！
    + 我之前看过其内部处理机制，其实就是给元素基于addEventListener做事件绑定，所以我之前开发的时候，如果遇到循环事件绑定，我可能会基于事件委托去处理，而不会给每个循环元素单独绑定，也算是提高一些性能吧！
    + 当然给子组件设置@，不是绑定事件，而是使用了发布订阅机制！
  @3 v-show/v-if，都是控制元素的显示隐藏的
    + 只不过 v-show，只是控制元素的 display 样式值，不论值是啥，元素本身会被渲染
    + 而 v-if 其内部是控制元素的渲染和销毁，如果经常来回切换，性能会消耗比较大
    + 所以平时开发的时候，如果需要频繁进行显示隐藏的切换（比如：选项卡效果），使用v-show会更好一些！但是如果切换不频繁（比如：第一次加载页面，没有数据先展示骨架屏，等待有数据后，再渲染真实的数据），我一般都是基于 v-if 来处理的！！
    + 不过有一点，v-if="false"的时候，元素是不会渲染的，此时如果想获取真实的DOM，必须基于v-show来处理，我之前项目中，实现触底加载，就遇到这样的问题！
  @4 v-for，主要用来循环绑定数据或者创建元素的
    + 不过要注意，v-for和v-if不要作用在相同的元素上，因为存在优先级问题
    + 而且要给 v-for 的元素设置唯一的key，只不过最好不要用索引作为key
  @5 v-bind（也就是“:”），主要是用来给元素/组件的属性动态绑定值的
    + 只要绑定的值不是字符串，或者是一个状态/属性等，都需要基于 v-bind 处理
  其余还有一写偶尔会使用的指令，比如：
    + 基于 v-html 绑定内容，可以识别 html 标签
    + v-text 一般不用，我都是直接用 小胡子 渲染了
    + v-if还对应了v-else-if/v-else
    + 以及处理插槽的 v-slot
    + 最后还有几个优化类的指令
      + v-pre 可以让视图编译的时候，跳过某些元素，这些元素可以不编译
      + v-once 只让元素编译一次，以后组件更新就不再编译了
      这些一般都是用来处理那些静态内容，或者只需要渲染一次的内容的！
  除此之外，我还会创建一些自定义指令，来实现一些需求，例如：我之前创建过 v-power 来处理项目的权限校验；创建过 v-throttle 来实现函数的节流等...

回答完毕后的扩展问题？
  @1 对应 “v-model指令实现的原理，以及绑定给子组件后，其内部是如何处理的”
  @2 扩展
     + bind/call/apply
     + 面试官可能围绕着stop修饰符，问一些事件的传播机制/事件委托等，或者问一些常用的修饰符都有哪些！
     + 发布订阅设计模式？给子组件设置@的目的？
     + 修饰符：.native
  @4 扩展：
     + v-for和v-if的优先级问题
     + 为什么不建议使用索引作为key?{涉及DOM-DIFF算法}
  其余扩展：
    + 自定义指令的玩法和作用
    + v-html的安全问题
    + ...

==========================
面试题：v-model指令实现的原理，以及绑定给子组件后，其内部是如何处理的？
  先阐述一下v-model的作用「同上所述」
  对于v-model的实现机制，我之前项目不忙的时候，自己去研究过，发现给不同元素/组件设置v-model，其内部的处理机制上是有所不同的！
  @1 给文本框/文本域设置v-model
    <input type="text" v-model="text">
    其原理：
      + 首先会把text状态值，赋值给表单元素的value属性
      + 而且自动给表单元素设置一个input事件（内容输入事件）的监听，当表单内容改变的时候，会获取表单中的最新信息，然后手动去修改text状态值
      <input type="text" :value="text" @input="text = $event.target.value">
    而v-model还有对应的几个修饰符
      v-model.lazy.trim = "text"
      + .lazy：把监听的事件从 input 事件（内容输入），换为 change 事件（内容改变），这样可以降低事件触发的频率，类似于函数节流的效果！
      + .trim：把表单中获取的内容，去除首尾空格后，再赋值给状态
      + .number：把表单中获取的内容，转换为数字类型后，再赋值给状态

  @2 给单选按钮设置v-model「单选按钮一般都是同时出现两个及多个」
    其步骤和原理：
      + 给input[radio]绑定 value 属性，属性值就是当单选按钮被选中时，要赋值给状态的值
      + 再为其设置 v-model 指令，绑定一个状态信息
      + 在视图编译阶段，如果v-model绑定值相同，则他们会被分配到相同的组（容器存储），一组只能选中一个
      + 用绑定的状态值sex，和各radio中的value属性值进行比较，和谁一致，就让谁默认是选中态
      + 监听 radio 的 change 事件，当选择状态发生改变，会修改对应的状态值！

  @3 给复选框设置 v-model
    只有一个复选框
      <input type="checkbox" v-model="remember">
      + 基于v-model绑定的状态值 remember，需要是布尔类型值
      + 状态值是true/false，决定了 checkbox 默认的选中状态「true选中 false不选中」
      + 监听 checkbox 的 change 事件，当选中状态发生改变，对应的状态值 remember 也会跟着改
    有一组复选框
      <input type="checkbox" value="music" v-model="hobby">
      ...
      + 给每一个 checkbox 设置 value ，存储的值就是后期选中时，想要获取的值
      + 首先基于 v-model 进行分组，绑定相同状态的为一组，一组可以选中多项，所以状态值需要是一个数组
      + 其次，根据现有的状态值，和各 checkbox 的 value 进行匹配，和谁匹配上，就让谁默认选中
      + 最后，监听每一个 checkbox 的 change 事件，当任意 checkbox 的选中状态发生改变，都会迭代所有的 checkbox ，把选中项的 value 获取到，赋值给对应的状态！
  
  @4 给下拉框设置 v-model
    <select v-model="city">
      <option value="">全部</option>
      <option value="北京">北京</option>
      ...
    </select>
    + 其原理和给文本框/文本域绑定 v-model 类似
    + 首先把 状态值 赋值给 select 的 value 属性，控制其默认选中哪一项
    + 最后监听 select 的 change 事件，在选择项改变的时候，把最新选中的 value 值赋值给状态！
    <select :value="city" @change="city = $event.target.value">
      ...
    </select>

  @5 给子组件设置 v-model
    <child-demo v-model="num" />
    底层原理：<child-demo :value="num" @input="num = $event" />
      + 首先，把父组件的 num 状态值，基于 value 属性传递给子组件「子组件内部可基于 props 接收渲染」
      + 其次，给子组件事件池中注入一个名为 input 的自定义事件，绑定的方法是 num = $event「目的：修改父组件的 num 状态值」
      + 最后，在子组件内部，可以基于 $emit 方法，通知 input 自定义事件执行，传递第一个实参值，就是为父组件的 num 状态改的值！「代码：this.$emit('input',1000)」
      基于这样的机制，可以实现：父组件把状态信息基于属性传递给子组件，子组件内部也可以直接修改父组件的这个状态值，实现父子组件之间的实时通信！
    + 在子组件中，我们还可以基于 model 配置项，自定义 传递属性/自定义事件 的名称
      model: {
        prop: 'value',
        event: 'update'
      }
      --->相当于
      <child-demo :value="num" @update="num = $event" />
    ----
    上面全面的玩法，其实有更简单的处理方式，v-bind 中的 sync 修饰符！！
      <B :x.sync="num" :y.sync="text"/>
      + 基于 x 属性，把父组件的 num 状态值，传递给子组件
      + 向子组件的事件池中，注入一个 update:x 的自定义事件
      <B :x="num" @update:x="num = $event" :y="text" @update:y="text = $event"/>
      相比较于 v-model ，这种方式更加的灵活，无需基于 model 自定义 属性名/自定义事件名 了！而且可以给多个属性，都这是 .sync！


    






==========================
Vue2框架常见的面试题
+ Vue怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？
+ v-show 与 v-if 有什么区别？
+ Class 与 Style 如何动态绑定？
+ 开发中常用的Vue指令有哪些
+ 在 Vue 组件 <style lang='less' scoped> 中编写的样式没有生效，都可能存在哪些原因？以及该如何解决？
+ computed 和 watch 的区别和运用的场景？
+ 谈谈你对 Vue2 生命周期的理解？
+ 简单说一下 $nextTick 的作用及实现原理？
+ Vue 组件中的 data 为什么必须是函数？
+ 说一下 .native / .sync 修饰符的作用及原理！
+ 怎样理解 Vue 的单向数据流？
+ Vue 组件间通信有哪几种方式？
+ 父组件可以监听到子组件的生命周期吗？
+ 平时开发中，你有没有封装过公共组件？如果封装过，则简单说一下你当时是怎么考虑的！
+ 介绍一下你对vuex的理解？
+ vuex 页面刷新数据丟失怎么解决？
+ 说说你对 SPA 单页面的理解，它的优缺点分别是什么？
+ 介绍一下路由的两种实现模式：hash模式 和 history模式
+ 介绍一下 vue-router 中的导航守卫函数
+ 说一下路由跳转的方案及传参方式有哪些？
+ 介绍一下你对vue-router的理解？
+ vue中组件和插件有什么区别？
+ 说说你对Vue.mixin的理解，有什么应用场景？