从输入URL地址到看到页面，中间都经历了啥？
  第一步：URL地址解析
    http://www.xxx.com:80/index.html?lx=1&from=weixin#video
    + URI/URL/URN
      URI：统一资源标识符
      URL：统一资源定位符
      URN：统一资源名称
    + 传输协议
      作用：负责客户端和服务器端之间信息的传输（可以理解为快递小哥）
      http（Hypertext Transfer Protocol）：超文本传输协议（除传输文本内容外，还可传输图片和音视频等）
      https（Hypertext Transfer Protocol Secure）：HTTP + SSL 更安全的传输协议（经过加密处理）
      ftp（File Transfer Protocol）：文件传输协议，主要用于往服务器上，上传和下载内容
    + 域名
    + 端口号
      作用：区分相同服务器上部署的不同项目的，取值范围 0~65535 之间
      浏览器有默认端口号机制：我们在地址栏中输入URL地址，如果没有写端口号，则浏览器会根据当前的传输协议，自动把端口号加上！！
        + http -> 80
        + https -> 443
        + ftp -> 21
    + 请求资源的路径名称
    + 问号传参信息
    + 哈希值「Hash值」
  
  第二步：缓存检查
    针对静态资源文件（例如：html、css、js、图片、音视频...）：强缓存和协商缓存
    缓存存储的位置：虚拟内存（Memory Cache）、物理内存（Disk Cache）
      + 正常刷新页面：先从虚拟内存中获取，如果不存在，再去物理内存中查找
      + 关闭页面重新打开，直接去物理内存中查找
      + 强制刷新页面（CTRL+F5），直接去服务器获取最新的
    不论是强缓存还是协商缓存，都是由服务器进行设置，浏览器自动配合完成相应的缓存机制！！
    ----
    @1 强缓存
      第一次访问网站，本地没有任何的缓存，需要向服务器发送请求；服务器在返回相应资源信息的时候，如果想开启强缓存机制，会在响应头中设置相关的字段：
        Expires：存储缓存过期的具体时间「HTTP/1.0」
        Cache-Control：存储过多久缓存将过期（单位：秒）或者其它信息「HTTP/1.1」
      当浏览器获取到服务器返回的资源信息，除了正常的渲染以外，还会去看响应头中是否有 Expires/Cache-Control 字段，如果没有，则啥都不处理，如果有，则把本次获取的资源信息和这两个响应头信息，缓存在客户端本地！
      第二次及以后访问这个网站，首先看本地是否有”具备有效期的缓存信息“
        没有/过期了：重新向服务器发送请求，来获取最新的资源
        有：则直接渲染缓存中的信息，无需再向服务器发送请求了
      强缓存的几个特点：
        + 不论从服务器还是缓存中获取，只要可以拿到，HTTP状态码都是200
        + “html页面千万不要做强缓存”，以此来保证，即便本地有生效的缓存，但是只要服务器资源更新了，也要从服务器实时获取最新的资源进行渲染！！
          + 我们平时开发的时候，需要基于 webpack/vite 等前端工具，对代码进行编译打包，把编译后的内容部署到服务器上！
          + 在webpack编译的时候，我们可以设置一个规则：根据文件的内容，让生成的文件名带唯一的HASH值（例如 main.sare3fd9jk.js）；这样只要代码修改了，每次打包都会创建不同的文件出来，而html页面中导入的也是最新的文件！
          + 这样只要html不做强缓存，就可保证，服务器资源一但更新，我们获取的是最新资源，而不是本地缓存！
    ----
    @2 协商缓存
      协商缓存是强缓存的一种补充「如果强缓存还在有效期，即便服务器设置了协商缓存，那么协商缓存的机制也不会触发；只有没有强缓存或者强缓存失效了，设置的协商缓存机制才会生效！！」
      第一次访问网站，本地啥缓存都没有，需要从服务器获取；如果服务器想对当前的资源设置协商缓存，则在响应头中返回/设置相关的字段：
        Last-Modified：存储该资源在服务器最后一次修改的时间「HTTP/1.0」
        ETag：存储该资源在服务器最后一次修改的标识(唯一的)「HTTP/1.1」
      浏览器获取资源信息的同时，观察响应头信息，如果具备这两个字段，则把资源和标识都缓存在本地！
      第二次访问网站，不论本地缓存是否生效（前提：强缓存肯定是没有或者失效了），都需要重新向服务器发送请求，并且在请求头中携带两个字段：
        If-Modified-Since：存储的值是Last-Modified的值
        If-None-Match：存储的值是ETag的值
      服务器接收传递的信息及标识，用 If-Modified-Since/If-None-Match 和当前服务器上最新的资源进行对比
        对比后是一样的：说明服务器上的这个资源没有更改过，则服务器直接返回 304 「Not-Modified」，浏览器接收到这个状态码，则从本地缓存中获取资源信息进行渲染
        对比后是不一样的：说明服务器上的这个资源更改过，此时服务器返回 状态码200、最新的资源信息、最新的Last-Modified/ETag值 ！浏览器获取最新的信息后，除了渲染，再把最新的信息和标识缓存在本地！
    ----
    @3 基于ajax/fetch从服务器获取的数据，不能设置强缓存和协商缓存，如果需要对不经常更新的数据进行缓存，需要开发者基于本地存储进行处理！
      + 最好的数据缓存方案是：vuex/redux「既可以避免频繁向服务器发送请求，也可以保证在用户刷新后，可以及时从服务器获取到最新的信息」
      + 但是对于一些不经常更新的数据，基于localStorage来存储（自己设定时效性）也是不错的选择！
        const query = async function query() {
            // 执行QUERY方法的第一件事情：先看本地是否有此数据的缓存
            let result = storage.get('CACHE', 7 * 24 * 60 * 60 * 1000)
            if (result) {
                // 本地是具备有效缓存的，则停止向服务器发送请求
                console.log('请求成功：', result)
                return
            }
            // 数据没有缓存过：则向服务器发送请求
            try {
                let result = await axios.get('/api/list', {
                    params: {
                        lx: 'my'
                    }
                })
                console.log('请求成功：', result)
                // 请求成功：把请求的结果存储到本地
                storage.set('CACHE', result)
            } catch (_) { }
        }
        query()

  第三步：DNS解析
    所谓DNS解析，就是去DNS服务器上，基于域名获取服务器的外网IP地址(主机地址)
    DNS解析也是有缓存机制的「比如谷歌浏览器记录“DNS解析”的缓存时间，大概是1分钟左右」
    @1 基于“递归查询”在本地缓存中查找DNS解析记录
      浏览器DNS解析缓存 -> 本地Host文件 -> 本地DNS解析器缓存 -> 本地DNS服务器
    @2 基于“迭代查询”在DNS服务器上查找DNS解析记录
      根域名服务器 / 顶级域名服务器 / 权威域名服务器
      每一次DNS解析的时间，大概在 20~120 毫秒左右
    ----
    单纯这样看，减少DNS的解析次数，会提高页面的加载速度！想要减少DNS的解析次数，需要把所有的资源，部署在相同服务器的相同服务下！！
    但是在真实的项目中，我们往往要把不同的资源部署到不同的服务器上「例如：静态资源服务器、图片和音视频服务器、数据请求服务器...」，这样会导致网站中出现多个域名请求，也就需要多个DNS解析！！
      + 资源的合理利用
      + 降低单一服务器的压力，提高并发上限
      + ...
    ----
    在DNS解析次数增加的情况下，我们可以基于 dns-prefetch 「DNS预解析」，来提高网站的加载速度！
      <link rel="dns-prefetch" href="//static.360buyimg.com">
      ...
      DNS预解析的原理：就是利用浏览器的多线程机制，在GUI渲染的同时，开辟新的线程去解析域名(解析的结果会缓存在浏览器中)，这样当GUI渲染到一定的阶段，遇到新的资源请求的时候，可能域名已经解析过了，直接用缓存中存储的外网IP，去服务器发送请求即可，不用再解析了！！
    
  第四步：TCP三次握手
    目的：根据DNS解析出来的服务器主机地址，建立起和服务器之间的传输通道
    为了保证传输通道的稳定性，需要进行“三次握手”
  
  第五步：客户端和服务器之间的数据通信
    客户端向服务器发送请求，把一些信息传递给服务器「Request请求阶段」
      + 请求起始行：请求方式、请求地址(包括问号传参信息)、HTTP协议的版本
      + 请求头(首部)：各种各样的键值对  Content-Type、Cookie、User-Agent、Authorization...
      + 请求主体(Request Payload)：请求主体中的数据格式是有限制的
        + 支持字符串
          + JSON格式的字符串  Content-Type:application/json
          + urlencoded格式的字符串  xxx=xxx&xxx=xxx   Content-Type:application/x-www-form-urlencoded
          + 普通字符串  Content-Type:text/plain
        + 支持 FormData 格式对象「主要用于文件上传」   Content-Type:multipart/form-data
        + 支持 Buffer/二进制 等格式数据
        + ...
        + 不支持其余的对象格式
          + 如果请求主体中，我们传递的是普通对象，则浏览器默认会把其变为普通字符串（例如：“[object Object]”）传递给服务器
          + 在Axios内部，如果我们传递的是普通对象，其内部会默认把普通对象变为JSON格式字符串，基于请求主体传递给服务器！
    服务器接收客户端的请求，把客户端需要的信息返回给客户端「Response响应阶段」
      + 响应起始行：HTTP协议的版本、HTTP响应状态码
      + 响应头：Connection: keep-alive、Date「服务器时间」...
      + 响应主体：一般返回的都是JSON格式字符串，但也有可能是其它的格式（例如 xml、buffer...）
    HTTP事物：Request + Response
    HTTP报文：请求(响应)起始行/头/主体，统称为HTTP报文！「在控制台的Network中可查看详细的报文信息」
  
  第六步：TCP四次挥手
    目的：把建立好的传输通道释放掉
    当客户端把信息发送给服务器后，紧接着就发起第一次挥手：我把信息给你了，你记得接收哈
    服务器接收到客户端的请求和传递的信息后
      + 服务器端发起第二次挥手：请求我收到了，你稍等一会吧，我现在去给你准备东西
      + 准备客户端需要的信息
      + 把信息返回给客户端
      + 服务器端发起第三次挥手：东西已经给你了，你记得接收一下，我这边打算关闭通道了
    客户端收到服务器返回的内容后，再次给服务器一个回馈（第四次挥手）：东西我收到了，谢谢，我这边也关闭了
    ----
    如果每一次请求都重新的“三握四挥”，这样太浪费性能和时间了。我们期望第一次请求，把传输通道建立好后，当本次HTTP事物完成后，这个通道先不要关闭，保留一段时间，让后面的请求，继续基于这个通道通信即可！
    解决方案：请求/响应头中设置 Connection: keep-alive , 保持TCP通道的长链接即可「HTTP/1.1版本中，自动就设置了keep-alive长链接机制，服务器端可以修改长链接的时间或者次数」

  第七步：客户端渲染
    浏览器把服务器返回的信息(包括html/css/js/图片/数据等)进行渲染，最后绘制出对应的页面！！
    @1 构建 DOM-Tree「DOM树」
      当从服务器获取HTML页面后，浏览器会分配 GUI渲染线程，自上而下进行解析！
        + 遇到 <link> ：分配一个新的HTTP网络线程去服务器获取样式资源，同时GUI继续向下渲染
        + 遇到 <style>：虽然不需要去服务器获取样式，但是此时的样式是不渲染的，只有等待DOM-Tree构建完毕后，并且其余基于<link>获取的样式也回来了，才会按照原定的顺序(编写的顺序)进行渲染！
        + 遇到 @import：也会分配一个HTTP线程去服务器获取样式资源，只不过其会阻碍GUI的渲染，只有等待样式资源获取完毕后，GUI才会继续向下渲染！
        + 遇到 <img>/<audio>/<video>：和 <link> 一致
          但是对于音视频来讲，如果设置了 preload="none" 属性，则开始渲染页面的时候，并不会去服务器获取音视频资源！
        + 遇到 <script> ... </script>：立即把JS代码执行（交给JS引擎线程渲染，但是GUI会暂定，也相当于阻碍了GUI渲染）
        + 遇到 <script src=''>：阻碍GUI渲染，分配一个新的HTTP线程去服务器获取JS资源，等待JS代码获取到之后，交由JS引擎线程去渲染，只有JS代码执行完毕，才会继续GUI的渲染！
        + 遇到 <script src='' async>：分配HTTP线程去获取JS资源，此时GUI会继续渲染，但是等到JS代码获取到之后，会立即停止GUI的渲染，先把JS执行！
        + 遇到 <script src='' defer>：和<link>一致了，会分配HTTP线程去获取JS资源，GUI继续向下渲染，等待DOM-Tree渲染完毕，并且其它设置defer的JS资源也获取到了，再按照编写的顺序，依次执行JS！
      当把所有的HTML结构解析完毕后，会构建出DOM元素之间的层级关系，这就是DOM树！
      在DOM树构建完毕后，会触发一个事件：DOMContentLoaded
        window.addEventListener('DOMContentLoaded',function(){ 
          // 此函数中，一定可以获取到页面中已经渲染出来的DOM元素
          ... 
        })
    @2 构建 CSSOM-Tree「样式树」
      等待样式资源从服务器获取到之后，会按照既定的顺序，开始渲染CSS样式，最后生成 CSSOM-Tree！
      CSS样式被称之为“层叠样式表”，就是因为其实具备：层级、权重、继承的
    @3 把 DOM-Tree和CSSOM-Tree 合并在一起，创建 Render-Tree「渲染树」
      渲染树中，已经非常清楚的知道了：DOM元素的层级和每一个元素的样式
    @4 Layout 布局排列计算「回流/重排 Reflow」
      根据当前视口的大小，计算元素在视口中的位置以及相关的样式
    @5 分层
      在一个页面中，不仅仅只有一层，它是一个3D空间，会存在很多层「所谓的脱离文档流」
      而分层的目的就是：把每一层及每一层中的元素样式都详细的规划好，包括具体的绘制步骤
    @6 Painting 绘制「重绘 Repainting」
      开始一层层的，按照规划好的步骤进行绘制，直到整个页面都被绘制完毕！

-------------
平时项目开发中的一些优化技巧
  @1 建议把 <script> 都放在页面的底部，防止其阻碍GUI的渲染，而且在JS中也可以获取到渲染后的DOM元素了
  @2 如果我把 <script> 放在了页面顶部，此时在JS中是拿不到DOM元素的，该如何解决？
    + 设置 defer 属性
    + 可以监听 DOMContentLoaded/load 事件，在事件中去获取DOM元素
      DOMContentLoaded：只要DOM-Tree构建完毕后就触发
      load：只有所有资源都加载完毕才会触发
  @3 平时开发的时候，如果把 <script> 都放在了页面底部，那么 defer/async 可以不加；如果没有都放在底部，我们可以设置 defer/async 来减轻对GUI渲染的阻碍！
    + 如果JS之间没有依赖关系，设置 async 即可，谁先获取到资源，就先把谁执行！
    + 如果之间是存在依赖的，那么只能设置 defer，要等待所有JS资源都获取到，再按照编写的顺序依次执行！
  @4 对于样式的处理，坚决不用 @import 导入式「除less/sass中的@import」
  @5 剩下的情况，如果样式代码比较少，建议我们使用内嵌样式（尤其是移动端），样式代码较多的情况下，还是使用外链式更好一些！！
  @6 而且要把 <link> 放在页面头部，让GUI和HTTP同时工作，加快页面的整体渲染进度！
  @7 同源下，我们可以同时分配的HTTP线程数量，最多是5~7个
     + CSS和JS建议进行合并压缩
     + 第一此渲染页面的时候，对于图片/音视频等资源，一定要开启懒加载，不要让这些资源，占据有限的HTTP线程数，并且第一次渲染如果不渲染图片，页面绘制的速度会更快！！

-------------
常见的HTTP状态码
  200 成功
  206 断点续传
  301 永久重定向「一般用于域名迁移」
  302/307 临时转移/重定向「一般用于服务器的负载均衡」
  304 协商缓存「服务器资源没有更新」
  400 请求参数有误
  401 无权限访问
  403 服务器拒绝访问「原因没有告知」
  404 请求地址不存在
  405 请求方式不被允许
  408 请求超时
  500 未知的服务器错误
  502 服务器网关错误
  503 服务器超负荷

-------------
常用的请求方式
  GET系列：GET、HEAD、DELETE、OPTIONS
  POST系列：POST、PUT、PATCH
  平时开发的时候，大家约定俗成的规范：基于GET系列发送请求，我们把传递的信息以“问号传参”的方式发送给服务器，如果是基于POST系列发送请求，则我们把传递的信息，基于“请求主体”发送给服务器！
    @1 浏览器对于URL地址的长度是有限制的「IE 2KB、谷歌 8KB」, 而基于GET方式发送请求，需要把传递的信息，以问号传参的方式，拼接到URL的末尾，这样对于传递信息的大小就有了限制！而POST系列请求，是基于请求主体把信息给服务器，请求主体理论上是没有大小限制的（实际开发中我们会自行限制）！
    @2 GET请求容易产生缓存，而POST请求不会
      问题描述：如果很短的时间内，向服务器发送多个请求，这些请求的地址及传参信息都一模一样，那么后面请求很有可能获取的是第一个请求缓存的信息！
      解决方案：只要保证每一次请求传递的参数不完全一致即可「多加一个参数 _=随机数/时间戳 」
      xhr.open('GET',`/api/list?lx=1&name=AA&_=${+new Date()}`)
    @3 GET请求相对于POST请求来讲，是不安全的「但是POST也不安全，互联网面前人人都在裸奔」
      有一个非常简单的“黑客”技术：URL劫持
      不论是何种请求方式，请记住，他们都是“明文”传输，所以对于重要的信息，一定要记得“加密”！

-------------
TCP VS UDP
  TCP经过三次握手，建立起一个“稳定可靠”的传输通道；但是因为每一次的通信，都需要经过三次握手，确保通道稳定后再传输，这样导致传输效率慢！
  UDP是不需要经过三次握手的，每一次的传输都是直接进行，这样保证传输的效率，但是不能保证传输的稳定性！

-------------
本地存储方案：
  @1 cookie
    本地存储：有期限的限制（可以自己设置过期期限），在期限内，不论页面刷新还是关闭，存储的信息都会在
  @2 localStorage
    本地持久化存储：页面刷新或者关闭，存储的信息一直存在，除非手动清除(或者卸载浏览器)，而且没有有效期的限制
  @3 sessionStorage
    本地会话存储，会话结束（浏览器页面关闭），存储的信息会自动清除
    但是刷新页面，会话不算结束，基于sessionStorage存储的信息是还在的
  @4 IndexedDB / WebSQL
    本地数据库存储「利用浏览器自带的数据库」
    相对于其它的本地存储方案，其可以存储更多的数据
  @5 虚拟内存存储
    特点：页面刷新或者关闭，存储的信息都会被清除掉
    + 全局变量
    + vuex
    + redux
    + ...
  -----
  不论哪一种本地存储方案，都受到 浏览器和源 的限制！
  不论哪一种本地存储方案，都是以“明文”形式进行存储的！「尽可能不存储“需要安全限定”的数据，即便要存储，一定要记得加密处理」
  -----
  cookie VS localStorage
    + 时效性：cookie可以设置过期时间，而localStorage是持久化存储「真实项目中，我们需要自己实现一套“具备有效期的localStorage存储方案”」
    + 存储大小：同源下，cookie最多只允许存储4KB内容，而localStorage允许最多存储5MB
    + 稳定性：cookie是不稳定的，基于“清除历史记录、安全卫士清扫垃圾”等操作，都可能会把存储的cookie给干掉；但是这些操作对localStorage无效！
    + 限制规则：某些浏览器具备“隐私模式/无痕浏览模式”，在这种模式下，cookie存储的信息不会被保留，localStorage也受到了影响！
    + 和服务器端的关系：cookie和服务器之间是有“猫腻儿”的，而localStorage和服务器端没有直接的关系
      + 服务器返回给客户端信息的时候，如果在响应头中携带了 Set-Cookie 字段，则客户端浏览器，会自动在本地设置一个cookie，把Set-Cookie字段中的信息进行存储！
      + 客户端本地只要存储了cookie，不论服务器是否需要，每一次向服务器发送请求的时候，浏览器都会自动在请求头中，基于Cookies字段，把本地存储的cookie信息，都传递给服务器！
      + 但是以上的处理，仅限同源访问，因为在非同源策略中，默认是禁止Cookie的传输的！
      + 基于localStorage存储的信息，除非手动发送给服务器，否则和服务器没有半毛钱关系！！
    + cookie可以兼容到IE5，但是localStorage是H5新增的，只能兼容到IE9及以上浏览器！
    
-------------
辅助知识点：URL地址的编译（编码和解码）
  情况1：基于 encodeURI/decodeURI 对整个URL进行编码解码
    let url='http://www.xxx.com/哈 哈.html'
    + 只处理了中文和空格等，对于比较特殊的字符（例如：// : ? # & 等）不处理
  情况2：基于 encodeURIComponent/decodeURIComponent 对URL地址中的某一部分进行编码和解码
    let url='http://www.xxx.com/index.html?name=珠峰&from=http://www.weixin.com/'
    + 在encodeURI的基础上，还会对 “// : ? # &” 等特殊符合编码 
    url=`...?name=${encodeURIComponent('珠峰')}&from=${encodeURIComponent('http://www.weixin.com/')}`
  还可以基于 escape/unescape 达到类似于 encodeURIComponent 的效果，只不过：escape一般只有前端有，后端语言中很少具备这个API！所以，建议大家还是使用 encodeURIComponent或者encodeURI（因为大部分后端语言，都具备这样的API）！ 