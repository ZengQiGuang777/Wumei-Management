什么是事件？
  事件是浏览器赋予元素的默认行为，即便什么都不处理，元素该具备的事件都有！
  浏览器标准事件：https://developer.mozilla.org/zh-CN/docs/Web/Events#%E6%A0%87%E5%87%86%E4%BA%8B%E4%BB%B6

什么是事件绑定？
  给元素的事件行为绑定方法，当事件行为触发，会执行对应的方法！
  DOM0事件绑定：
    box.onclick = function(){ ... }
    原理：给元素对象的 onxxx 事件私有属性赋值
      + 只能给元素的此事件行为绑定一个方法
      + 必须拥有此事件私有属性才可以，某些标准事件是没有对应的事件私有属性的「例如：DOMContentLoaded」
  DOM2事件绑定：
    box.addEventListener('click',function(){ ... },布尔/对象)
      + 最后参数是布尔类型值，是控制触发的阶段  true:捕获  false:冒泡
      + 最后参数是对象，则是设置相关的配置项 
        + capture 控制触发阶段
        + once 只能触发一次，触发完毕后，会自动基于 removeEventListener 移除事件绑定
        + passive 设置为true之后，则禁止阻止默认行为
    原理：利用浏览器内置的事件池机制，完成事件绑定及触发管理的
      + 只要是浏览器支持的标准事件，都可以用 addEventListener 做事件绑定「比DOM0的功能强大」
      + 可以给同一个元素的同一个事件类型，绑定多个不同方法，当事件触发的时候，所有绑定的方法会依次被触发执行

什么是事件对象？
  所谓事件对象，就是一个对象，只不过记录了本次触发的相关信息；当事件触发，绑定的方法执行，会把分析好的事件对象，作为实参传递给每个函数！！
    box.addEventListener('click',function(ev){ 
       // ev：获取的事件对象信息
    })
  常用的事件对象：MouseEvent(PointerEvent/TouchEvent)、KeyboardEvent、Event...
  事件对象中常用的信息：
    altKey: false
    ctrlKey: false
    shiftKey: false
    clientX/clientY 操作点距离可视窗口的坐标
    pageX/pageY 操作点距离BODY的坐标
    srcElement/target 事件源
    type 事件类型
    which/keyCode 键盘的按键码
    ...
    preventDefault 阻止默认行为
    stopPropagation/stopImmediatePropagation 阻止事件传播
    composedPath 获取传播的路径「事件源 -> ... -> Window」
    ...

事件的传播机制
  对于支持事件传播的事件行为来讲，当事件行为触发的时候，会经历三个阶段：
    CAPTURING_PHASE: 1 捕获阶段「从window开始查找，一直找到事件源，其目的是为冒泡阶段分析好传播路径」
    AT_TARGET: 2 目标阶段「把事件源的相关事件行为触发」
    BUBBLING_PHASE: 3 冒泡阶段「并让其祖先元素的相关事件行为也被触发，而且是从事件源 -> Window」
  有一些事件行为是不支持“事件传播”的，例如：
    + mouseenter/mouseleave
    + load
    + ...

事件委托「事件代理」
  事件委托就是利用事件的传播机制，来实现的一种项目解决方案
  例如：一个容器中有很多后代元素，其中大部分后代元素，在点击的时候，都会处理一些事情「有些元素点击做相同的事情，有些点击做不同的事情」
    @1 传统方案：想操作哪些元素，就把这些元素全部都获取到，然后逐一做事件绑定
       这种方案不仅操作起来复杂，并且会开辟很多堆内存，性能也不是很好
    @2 新方案：利用事件的传播机制，不逐一获取元素和单独绑定事件了，而是只给外层容器做一个事件绑定，这样不管点击其后代中的哪一个元素，当前容器的点击事件也会触发，把绑定的方法执行；在方法中，我们只需要判断事件源是谁，从而处理不同的事情即可！ ===> 事件委托
       这种新方案的性能比传统方案提高40%以上！
  例如：我们容器中的元素不是写死的，而是动态绑定(动态创建)的，而且会持续动态创建；我们需要在点击每个元素的时候，做一些事情！
    @1 传统方案：每一次动态创建完，都需要获取最新的元素，给这些元素单独做事件绑定！
    @2 事件委托：只需要给容器的点击事件绑定方法，不论其内部元素是写死的，还是动态绑定的，只要点击了，都说明元素已经存在了，基于事件传播机制，我们只需要在外层容器中判断事件源，做不同的事情即可！
       事件委托可以给动态绑定的元素做事件绑定！！
  真实项目中还有很多需求，必须基于事件委托来完成！所以：以后再遇到事件绑定的需求，首先想是否有必要基于事件委托处理，如果确定有必要，则直接基于事件委托处理！

mouseenter VS mouseover

拖拽操作：
  @1 mousedown/mousemove/mouseup 「注意：鼠标焦点丢失问题」
  @2 dragstart/drag/dragend 拖拽事件
     dragenter/dragleave/drop 拖拽中让元素进入/离开目标位置&放在目标位置上
     使用这套事件模型，需要给元素设置draggable属性