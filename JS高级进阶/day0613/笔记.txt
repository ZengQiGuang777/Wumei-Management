从输入URL地址到看到页面，中间都经历了啥？
  第一步：URL地址解析
    http://www.xxx.com:80/index.html?lx=1&from=weixin#video
    + URI/URL/URN
      URI：统一资源标识符
      URL：统一资源定位符
      URN：统一资源名称
    + 传输协议
      作用：负责客户端和服务器端之间信息的传输（可以理解为快递小哥）
      http（Hypertext Transfer Protocol）：超文本传输协议（除传输文本内容外，还可传输图片和音视频等）
      https（Hypertext Transfer Protocol Secure）：HTTP + SSL 更安全的传输协议（经过加密处理）
      ftp（File Transfer Protocol）：文件传输协议，主要用于往服务器上，上传和下载内容
    + 域名
    + 端口号
      作用：区分相同服务器上部署的不同项目的，取值范围 0~65535 之间
      浏览器有默认端口号机制：我们在地址栏中输入URL地址，如果没有写端口号，则浏览器会根据当前的传输协议，自动把端口号加上！！
        + http -> 80
        + https -> 443
        + ftp -> 21
    + 请求资源的路径名称
    + 问号传参信息
    + 哈希值「Hash值」
  
  第二步：缓存检查
    针对静态资源文件（例如：html、css、js、图片、音视频...）：强缓存和协商缓存
    缓存存储的位置：虚拟内存（Memory Cache）、物理内存（Disk Cache）
      + 正常刷新页面：先从虚拟内存中获取，如果不存在，再去物理内存中查找
      + 关闭页面重新打开，直接去物理内存中查找
      + 强制刷新页面（CTRL+F5），直接去服务器获取最新的
    不论是强缓存还是协商缓存，都是由服务器进行设置，浏览器自动配合完成相应的缓存机制！！
    ----
    @1 强缓存
      第一次访问网站，本地没有任何的缓存，需要向服务器发送请求；服务器在返回相应资源信息的时候，如果想开启强缓存机制，会在响应头中设置相关的字段：
        Expires：存储缓存过期的具体时间「HTTP/1.0」
        Cache-Control：存储过多久缓存将过期（单位：秒）或者其它信息「HTTP/1.1」
      当浏览器获取到服务器返回的资源信息，除了正常的渲染以外，还会去看响应头中是否有 Expires/Cache-Control 字段，如果没有，则啥都不处理，如果有，则把本次获取的资源信息和这两个响应头信息，缓存在客户端本地！
      第二次及以后访问这个网站，首先看本地是否有”具备有效期的缓存信息“
        没有/过期了：重新向服务器发送请求，来获取最新的资源
        有：则直接渲染缓存中的信息，无需再向服务器发送请求了
      强缓存的几个特点：
        + 不论从服务器还是缓存中获取，只要可以拿到，HTTP状态码都是200
        + “html页面千万不要做强缓存”，以此来保证，即便本地有生效的缓存，但是只要服务器资源更新了，也要从服务器实时获取最新的资源进行渲染！！
          + 我们平时开发的时候，需要基于 webpack/vite 等前端工具，对代码进行编译打包，把编译后的内容部署到服务器上！
          + 在webpack编译的时候，我们可以设置一个规则：根据文件的内容，让生成的文件名带唯一的HASH值（例如 main.sare3fd9jk.js）；这样只要代码修改了，每次打包都会创建不同的文件出来，而html页面中导入的也是最新的文件！
          + 这样只要html不做强缓存，就可保证，服务器资源一但更新，我们获取的是最新资源，而不是本地缓存！
    ----
    @2 协商缓存
      协商缓存是强缓存的一种补充「如果强缓存还在有效期，即便服务器设置了协商缓存，那么协商缓存的机制也不会触发；只有没有强缓存或者强缓存失效了，设置的协商缓存机制才会生效！！」
      第一次访问网站，本地啥缓存都没有，需要从服务器获取；如果服务器想对当前的资源设置协商缓存，则在响应头中返回/设置相关的字段：
        Last-Modified：存储该资源在服务器最后一次修改的时间「HTTP/1.0」
        ETag：存储该资源在服务器最后一次修改的标识(唯一的)「HTTP/1.1」
      浏览器获取资源信息的同时，观察响应头信息，如果具备这两个字段，则把资源和标识都缓存在本地！
      第二次访问网站，不论本地缓存是否生效（前提：强缓存肯定是没有或者失效了），都需要重新向服务器发送请求，并且在请求头中携带两个字段：
        If-Modified-Since：存储的值是Last-Modified的值
        If-None-Match：存储的值是ETag的值
      服务器接收传递的信息及标识，用 If-Modified-Since/If-None-Match 和当前服务器上最新的资源进行对比
        对比后是一样的：说明服务器上的这个资源没有更改过，则服务器直接返回 304 「Not-Modified」，浏览器接收到这个状态码，则从本地缓存中获取资源信息进行渲染
        对比后是不一样的：说明服务器上的这个资源更改过，此时服务器返回 状态码200、最新的资源信息、最新的Last-Modified/ETag值 ！浏览器获取最新的信息后，除了渲染，再把最新的信息和标识缓存在本地！
    ----
    @3 基于ajax/fetch从服务器获取的数据，不能设置强缓存和协商缓存，如果需要对不经常更新的数据进行缓存，需要开发者基于本地存储进行处理！
      + 最好的数据缓存方案是：vuex/redux「既可以避免频繁向服务器发送请求，也可以保证在用户刷新后，可以及时从服务器获取到最新的信息」
      + 但是对于一些不经常更新的数据，基于localStorage来存储（自己设定时效性）也是不错的选择！
        const query = async function query() {
            // 执行QUERY方法的第一件事情：先看本地是否有此数据的缓存
            let result = storage.get('CACHE', 7 * 24 * 60 * 60 * 1000)
            if (result) {
                // 本地是具备有效缓存的，则停止向服务器发送请求
                console.log('请求成功：', result)
                return
            }
            // 数据没有缓存过：则向服务器发送请求
            try {
                let result = await axios.get('/api/list', {
                    params: {
                        lx: 'my'
                    }
                })
                console.log('请求成功：', result)
                // 请求成功：把请求的结果存储到本地
                storage.set('CACHE', result)
            } catch (_) { }
        }
        query()

  第三步：DNS解析
    所谓DNS解析，就是去DNS服务器上，基于域名获取服务器的外网IP地址(主机地址)
    DNS解析也是有缓存机制的「比如谷歌浏览器记录“DNS解析”的缓存时间，大概是1分钟左右」
    @1 基于“递归查询”在本地缓存中查找DNS解析记录
      浏览器DNS解析缓存 -> 本地Host文件 -> 本地DNS解析器缓存 -> 本地DNS服务器
    @2 基于“迭代查询”在DNS服务器上查找DNS解析记录
      根域名服务器 / 顶级域名服务器 / 权威域名服务器
      每一次DNS解析的时间，大概在 20~120 毫秒左右
    ----
    单纯这样看，减少DNS的解析次数，会提高页面的加载速度！想要减少DNS的解析次数，需要把所有的资源，部署在相同服务器的相同服务下！！
    但是在真实的项目中，我们往往要把不同的资源部署到不同的服务器上「例如：静态资源服务器、图片和音视频服务器、数据请求服务器...」，这样会导致网站中出现多个域名请求，也就需要多个DNS解析！！
      + 资源的合理利用
      + 降低单一服务器的压力，提高并发上限
      + ...
    ----
    在DNS解析次数增加的情况下，我们可以基于 dns-prefetch 「DNS预解析」，来提高网站的加载速度！
      <link rel="dns-prefetch" href="//static.360buyimg.com">
      ...
      DNS预解析的原理：就是利用浏览器的多线程机制，在GUI渲染的同时，开辟新的线程去解析域名(解析的结果会缓存在浏览器中)，这样当GUI渲染到一定的阶段，遇到新的资源请求的时候，可能域名已经解析过了，直接用缓存中存储的外网IP，去服务器发送请求即可，不用再解析了！！
    
      

-------------
本地存储方案：
  @1 cookie
    本地存储：有期限的限制（可以自己设置过期期限），在期限内，不论页面刷新还是关闭，存储的信息都会在
  @2 localStorage
    本地持久化存储：页面刷新或者关闭，存储的信息一直存在，除非手动清除(或者卸载浏览器)，而且没有有效期的限制
  @3 sessionStorage
    本地会话存储，会话结束（浏览器页面关闭），存储的信息会自动清除
    但是刷新页面，会话不算结束，基于sessionStorage存储的信息是还在的
  @4 IndexedDB / WebSQL
    本地数据库存储「利用浏览器自带的数据库」
    相对于其它的本地存储方案，其可以存储更多的数据
  @5 虚拟内存存储
    特点：页面刷新或者关闭，存储的信息都会被清除掉
    + 全局变量
    + vuex
    + redux
    + ...
  -----
  不论哪一种本地存储方案，都受到 浏览器和源 的限制！
  不论哪一种本地存储方案，都是以“明文”形式进行存储的！「尽可能不存储“需要安全限定”的数据，即便要存储，一定要记得加密处理」
  -----
  cookie VS localStorage
    + 时效性：cookie可以设置过期时间，而localStorage是持久化存储「真实项目中，我们需要自己实现一套“具备有效期的localStorage存储方案”」
    + 存储大小：同源下，cookie最多只允许存储4KB内容，而localStorage允许最多存储5MB
    + 稳定性：cookie是不稳定的，基于“清除历史记录、安全卫士清扫垃圾”等操作，都可能会把存储的cookie给干掉；但是这些操作对localStorage无效！
    + 限制规则：某些浏览器具备“隐私模式/无痕浏览模式”，在这种模式下，cookie存储的信息不会被保留，localStorage也受到了影响！
    + 和服务器端的关系：cookie和服务器之间是有“猫腻儿”的，而localStorage和服务器端没有直接的关系
      + 服务器返回给客户端信息的时候，如果在响应头中携带了 Set-Cookie 字段，则客户端浏览器，会自动在本地设置一个cookie，把Set-Cookie字段中的信息进行存储！
      + 客户端本地只要存储了cookie，不论服务器是否需要，每一次向服务器发送请求的时候，浏览器都会自动在请求头中，基于Cookies字段，把本地存储的cookie信息，都传递给服务器！
      + 但是以上的处理，仅限同源访问，因为在非同源策略中，默认是禁止Cookie的传输的！
      + 基于localStorage存储的信息，除非手动发送给服务器，否则和服务器没有半毛钱关系！！
    + cookie可以兼容到IE5，但是localStorage是H5新增的，只能兼容到IE9及以上浏览器！
-------------
辅助知识点：URL地址的编译（编码和解码）
  情况1：基于 encodeURI/decodeURI 对整个URL进行编码解码
    let url='http://www.xxx.com/哈 哈.html'
    + 只处理了中文和空格等，对于比较特殊的字符（例如：// : ? # & 等）不处理
  情况2：基于 encodeURIComponent/decodeURIComponent 对URL地址中的某一部分进行编码和解码
    let url='http://www.xxx.com/index.html?name=珠峰&from=http://www.weixin.com/'
    + 在encodeURI的基础上，还会对 “// : ? # &” 等特殊符合编码 
    url=`...?name=${encodeURIComponent('珠峰')}&from=${encodeURIComponent('http://www.weixin.com/')}`
  还可以基于 escape/unescape 达到类似于 encodeURIComponent 的效果，只不过：escape一般只有前端有，后端语言中很少具备这个API！所以，建议大家还是使用 encodeURIComponent或者encodeURI（因为大部分后端语言，都具备这样的API）！ 